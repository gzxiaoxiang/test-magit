
* SICP的课后习题实现
** SICP的python实现结果
*** 第一章python版本书中程序

#+BEGIN_SRC python :results output
from operator import add,sub
import sys
print sys.version
print sys.prefix
print "hello world!"


#+END_SRC

#+RESULTS:
: 2.7.13 |Anaconda 4.3.1 (64-bit)| (default, Dec 19 2016, 13:29:36) [MSC v.1500 64 bit (AMD64)]
: d:\Anaconda2
: hello world!


** Grep命令使用及正则表达式（默认搜索当前路径下的文件，而不查询目录）
   功能说明：查找文件里符合条件的字符串（默认搜索当前路径下的文件，而
不查询目录，如果要查询目录需要添加-r 或者-d参数，否则结束）。
   http://www.linuxso.com/command/grep.html

语　　法：grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]

补充说明：grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为“-”，则grep指令会从标准输入设备读取数据。

参　　数：
  -a或--text   不要忽略二进制的数据。
  -A<显示列数>或--after-context=<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之后的内容。
  -b或--byte-offset   在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。
  -B<显示列数>或--before-context=<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之前的内容。
  -c或--count   计算符合范本样式的列数。
  -C<显示列数>或--context=<显示列数>或-<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
  -d<进行动作>或--directories=<进行动作>   当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
  -e<范本样式>或--regexp=<范本样式>   指定字符串做为查找文件内容的范本样式。
  -E或--extended-regexp   将范本样式为延伸的普通表示法来使用。
  -f<范本文件>或--file=<范本文件>   指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。
  -F或--fixed-regexp   将范本样式视为固定字符串的列表。
  -G或--basic-regexp   将范本样式视为普通的表示法来使用。
  -h或--no-filename   在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
  -H或--with-filename   在显示符合范本样式的那一列之前，表示该列所属的文件名称。
  -i或--ignore-case   忽略字符大小写的差别。
  -l或--file-with-matches   列出文件内容符合指定的范本样式的文件名称。
  -L或--files-without-match   列出文件内容不符合指定的范本样式的文件名称。
  -n或--line-number   在显示符合范本样式的那一列之前，标示出该列的列数编号。
  -q或--quiet或--silent   不显示任何信息。
  -r或--recursive   此参数的效果和指定“-d recurse”参数相同。
  -s或--no-messages   不显示错误信息。
  -v或--revert-match   反转查找。
  -V或--version   显示版本信息。
  -w或--word-regexp   只显示全字符合的列。
  -x或--line-regexp   只显示全列符合的列。
  -y   此参数的效果和指定“-i”参数相同。
  --help   在线帮助。


** SICP的scheme实现结果
*** 第三章习题
; Exercise 3.28: Define an or-gate as a primitive function box. Your or-gate constructor should be similar to and-gate.
(load "/home/soulomoon/git/SICP/Chapter3/signal.scm")

(define (inverter input output)
  (define (invert-input)
    (let ((new-value 
           (logical-not (get-signal input))))
         (set-signal! output new-value)))
  (add-action! input invert-input)
 'ok)

(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value
           (logical-or (get-signal a1) 
                        (get-signal a2))))
         (set-signal! output new-value)))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)

(define (logical-or a b)
  (if (or (= a 1) (= b 1))
      1
      0))

(define a (make-wire))
(define b (make-wire))
(define c (make-wire))


*** 全加器的模拟
  
     (define a (make-wire))
     (define b (make-wire))
     (define c (make-wire))

     (define d (make-wire))
     (define e (make-wire))
     (define s (make-wire))

     (define (half-adder a b s c)
       (let ((d (make-wire)) (e (make-wire)))
         (or-gate a b d)
         (and-gate a b c)
         (inverter c e)
         (and-gate d e s)
         'ok))

     (define (full-adder a b c-in sum c-out)
       (let ((s (make-wire))
             (c1 (make-wire))
             (c2 (make-wire)))
         (half-adder b c-in s c1)
         (half-adder a s sum c2)
         (or-gate c1 c2 c-out)
         'ok))


   (define (inverter input output)
       (define (invert-input)
         (let ((new-value (logical-not (get-signal input))))
           (after-delay inverter-delay
                        (lambda ()
                          (set-signal! output new-value)))))
       (add-action! input invert-input)
       'ok)

     (define (logical-not s)
       (cond ((= s 0) 1)
             ((= s 1) 0)
             (else (error "Invalid signal" s))))


 (define (and-gate a1 a2 output)
       (define (and-action-procedure)
         (let ((new-value
                (logical-and (get-signal a1) (get-signal a2))))
           (after-delay and-gate-delay
                        (lambda ()
                          (set-signal! output new-value)))))
       (add-action! a1 and-action-procedure)
       (add-action! a2 and-action-procedure)
       'ok)


  (define (make-wire)
       (let ((signal-value 0) (action-procedures '()))
         (define (set-my-signal! new-value)
           (if (not (= signal-value new-value))
               (begin (set! signal-value new-value)
                      (call-each action-procedures))
               'done))

         (define (accept-action-procedure! proc)
           (set! action-procedures (cons proc action-procedures))
           (proc))

         (define (dispatch m)
           (cond ((eq? m 'get-signal) signal-value)
                 ((eq? m 'set-signal!) set-my-signal!)
                 ((eq? m 'add-action!) accept-action-procedure!)
                 (else (error "Unknown operation -- WIRE" m))))
         dispatch))


     (define (call-each procedures)
       (if (null? procedures)
           'done
           (begin
             ((car procedures))
             (call-each (cdr procedures)))))

  (define (get-signal wire)
       (wire 'get-signal))

     (define (set-signal! wire new-value)
       ((wire 'set-signal!) new-value))

     (define (add-action! wire action-procedure)
       ((wire 'add-action!) action-procedure))


     (define (propagate)
       (if (empty-agenda? the-agenda)
           'done
           (let ((first-item (first-agenda-item the-agenda)))
             (first-item)
             (remove-first-agenda-item! the-agenda)
             (propagate))))

;;define cons and set-cdr set-car! 
 (define cons
    (lambda (x y)
        (define set-x!
            (lambda (v)
                (set! x v)))
        (define set-y!
            (lambda (v)
                (set! y v)))
        (define dispatch
            (lambda (m)
                (cond ((eq? m 'car)
                        x)
                      ((eq? m 'cdr)
                        y)
                      ((eq? m 'set-car!)
                        set-x!)
                      ((eq? m 'set-cdr!)
                        set-y!)
                      (else
                        (error "Undefined operation -- CONS" m)))))
        dispatch))

(define car
    (lambda (z)
        (z 'car)))

(define cdr
    (lambda (z)
        (z 'cdr)))

(define set-car!
    (lambda (z new-value)
        ((z 'set-car!) new-value)))

(define set-cdr!
    (lambda (z new-value)
        ((z 'set-cdr!) new-value)))


   (define (probe name wire)
       (add-action! wire
                    (lambda ()
                      (newline)
                      (display name)
                      (display " ")
                      (display (current-time the-agenda))
                      (display "  New-value = ")
                      (display (get-signal wire)))))

 (define the-agenda (make-agenda))
     (define inverter-delay 2)
     (define and-gate-delay 3)
     (define or-gate-delay 5)

 (define input-1 (make-wire))
     (define input-2 (make-wire))
     (define sum (make-wire))
     (define carry (make-wire))

     (probe 'sum sum)
(probe 'carry carry)

(half-adder input-1 input-2 sum carry)


* Emacs Lisp语法学习
** Emacs中实现c和C++以及elist代码的自动补全和跳转
有几种方式可以实现跳转，一个是利用emacs自带的etags，另一种是使用gtags，使用第一种方式时不用开启gtags模式，后者需要安装ggtags模式后，才能对C和C++进行跳转，但后者的功能更加强大一些。etags不能自动更新tags，需要通过etags+文件名来手动更新，但是gtags可以实现在保存文件的时候，自动更行gtags文件。
参考网址：https://segmentfault.com/a/1190000000502565
http://airekans.github.io/emacs/2012/05/18/find-tag-in-emacs

1.在Emacs中我们可以通过如下的方式得到变量和函数的帮助信息

  C-h -h 查看帮助信息

  C-h  b //查看键值绑定信息 (重要)

查找命令的名称或键盘快捷键
如果你知道一个命令的名字，你可以找到它的键盘快捷方式（如果有的话）。打电话describe-function。如果你知道一个键盘快捷方式，你可以找到它调用的命令。打电话describe-key。

           快捷键                    命令名称                      功能用法
 【Ctrl+ h k】    describe-key      查看一个键值用法及源码
 【Ctrl+ h  o】   describe-symbol   查看一个变量或函数用法及源码
2.下面的命令将打开整个EmacsManual
C-h  i m  elisp  RET //查看elisp教程

** emacs和正则表达式配合使用 
   M-x re-builer  手动生成正则表达式
   M-x regexp-builder 同上,手动生成正则表达式
   M-x regexp-opt  根据目标内容生成对应的正则表达式
   可以利用emacs的函数exgrep-opt自动生成一个高效的正则匹配表达式：
   (regexp-opt '("foobar" "foobaz" "foo"))按键"C-x C-e"在状态栏生成正则表达式
   (regexp-opt '("foobar" "foobaz" "foo"))按键"C-u C-x C-e"在当前光标处生成正则表达式
   (regexp-opt '("foobar" "foobaz" "foo"))"\\(?:foo\\(?:ba[rz]\\)?\\)"
   (regexp-opt '("foobar" "foobaz" "foo"))

   "\\(?:foo\\(?:ba[rz]\\)?\\)"

** Emacs Lisp编程入门书籍
   这本书是中文版，英文版本可以直接通过C-h i之后查询Emacs Lisp Intro直
   接运行其中的代码
*** 切换缓冲区   
(current-buffer)

(buffer-file-name)

(switch-to-buffer (other-buffer))

(buffer-size) 
(point)  


(point-min)
(point-max)
交互函数：
(defun multiply-by-seven (number)   ;version1
  "Multiply NUMBER by seven"
  (* 7 number))

(defun multiply-by-seven2 (number)  ;version2
  "Multiply NUMBER by seven"
  (interactive "p")
  (message "the result is %d" (* 7 number)))

(defun multiply-by-seven3 (buffer start end)  ;version3
  "Multiply NUMBER by seven"
  (interactive "BAppend to buffer: \nr"))
 ; (message "the result is %d" (* 7 number)))

3.6 let函数
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and anthor has %s."
	   zebra tiger))

3.7 if 函数

(if (> 4 5)
    (message "5 is greater than 4!")
  (message "4 is not greater than 5!"))

(defun type-of-animal (charac)
  "print message in echo area depending on charac"
  (if (equal charac 'tiger)
      (message "it is a tiger!")))
(type-of-animal 'tige)

(multiply-by-seven 7)






#+BEGIN_SRC emacs-lisp
(+ 2 3)

#+END_SRC 

#+RESULTS:
: 5



* Latex排版学习
 
